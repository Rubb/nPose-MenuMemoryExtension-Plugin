/*
The nPose scripts are licensed under the GPLv2 (http://www.gnu.org/licenses/gpl-2.0.txt), with the following addendum:

The nPose scripts are free to be copied, modified, and redistributed, subject to the following conditions:
    - If you distribute the nPose scripts, you must leave them full perms.
    - If you modify the nPose scripts and distribute the modifications, you must also make your modifications full perms.

"Full perms" means having the modify, copy, and transfer permissions enabled in Second Life and/or other virtual world platforms derived from Second Life (such as OpenSim).  If the platform should allow more fine-grained permissions, then "full perms" will mean the most permissive possible set of permissions allowed by the platform.
*/

#define DEFAULT_PREFIX "SET"

#define NC_READER_REQUEST 224
#define NC_READER_RESPONSE 225
#define PREPARE_MENU_STEP2 -821
#define PLUGIN_ACTION -830
#define PLUGIN_MENU -832
#define PLUGIN_MENU_DONE -833

#define MEMORY_USAGE 34334

//NC Reader
#define NC_READER_CONTENT_SEPARATOR "%&§"

//own plugins related
#define NPOSE_PLUGIN_MENU "npose_menu"
#define MME_PLUGIN_MENU_NAME "npose_mme"
#define MME_PLUGIN_SCRIPT_NAME "nPose MenuMemoryExtension Plugin"

//store plugins base paths
list MmePluginBasePathList;
list MmePluginWorkerNumberList;

string MenuNc = ".Change Menu Order"; //holds the name of the menu order notecard to read.
string MmeNc =".nPose MenuMemoryExtension"; //holds the name of the nPose MenuMemoryExtension configuration NC

list MenuPaths;
list MenuButtons;

key ScriptId;

integer UseMme; //MenuMemoryExtension
integer UseChangeMenuOrder;
integer MyWorkerNumber;
string MyPluginMenuName;


integer TotalNumberOfValidCards; //only for your info
integer TotalNumberOfStoredCards; //only for your info
/*
debug(list message){
    llOwnerSay((((llGetScriptName() + "\n##########\n#>") + llDumpList2String(message,"\n#>")) + "\n##########"));
}
*/

list getButtons(string path, list additionalButtons) {
    list choices;
    integer index = llListFindList(MenuPaths, [path]);
    if(~index) {
        choices=llParseStringKeepNulls(llList2String(MenuButtons, index), ["|"], []);
    }
    //Merge the buttons generated by NCs (choices) and the buttons generated by a plugin (additionalButtons)
    integer length=llGetListLength(additionalButtons);
    for(index=0; index<length; index++) {
        integer searchIndex=llListFindList(choices, [llList2String(additionalButtons, index)]);
        if(~searchIndex) {
            choices=llDeleteSubList(choices, searchIndex, searchIndex);
        }
    }
    choices+=additionalButtons;
    return choices;
}

BuildMenus(list cardNames) {//builds the user defined menu buttons
    integer length = llGetListLength(cardNames);
    if(!UseChangeMenuOrder) {
        length = llGetInventoryNumber(INVENTORY_NOTECARD);
    }
    integer indexNC;
    for(indexNC=0; indexNC<length; ++indexNC) {//step through the notecards
        string path = llList2String(cardNames, indexNC);
        if(!UseChangeMenuOrder) {
            path = llGetInventoryName(INVENTORY_NOTECARD, indexNC);
        }
        AddMenuButton(path, FALSE);
    }
}

AddMenuButton(string path, integer addUnconditional) {
    integer permsIndex1 = llSubStringIndex(path,"{");
    integer permsIndex2 = llSubStringIndex(path,"}");
    if(permsIndex1>0 && permsIndex2>permsIndex1) { // found
        path = llDeleteSubString(path, permsIndex1, permsIndex2);
    }
    list pathParts = llParseStringKeepNulls(path, [":"], []);
    string prefix = llList2String(pathParts, 0);

    if(prefix==DEFAULT_PREFIX || (llStringLength(prefix)==2 && llToUpper(prefix)==prefix)) { // found
        TotalNumberOfValidCards+=!addUnconditional;
        integer storeCard=TRUE;
        if(UseMme && !addUnconditional) {
            if(getMmeWorkerNumber(path)!=MyWorkerNumber) {
                storeCard=FALSE;
            }
        }
        if(storeCard) {
            TotalNumberOfStoredCards+=!addUnconditional;
            while(llGetListLength(pathParts)>1) {
                string last = llList2String(pathParts, -1);
                string parentPath = llDumpList2String(llDeleteSubList(pathParts, -1, -1), ":");
                integer indexParentPath = llListFindList(MenuPaths, [parentPath]);
                if(~indexParentPath) {
                    list children = llParseStringKeepNulls(llList2String(MenuButtons, indexParentPath), ["|"], []);
                    if(!~llListFindList(children, [last])) {
                        children += [last];
                        if(!UseChangeMenuOrder) {
                            children = llListSort(children, 1, 1);
                        }
                        MenuButtons = llListReplaceList(MenuButtons, [llDumpList2String(children, "|")], indexParentPath, indexParentPath);
                    }
                }
                else {
                    MenuPaths += [parentPath];
                    MenuButtons += [last];
                }
                pathParts = llDeleteSubList(pathParts, -1, -1);
            }
        }
    }
}



//helper
string deleteNodes(string path, integer start, integer end) {
    return llDumpList2String(llDeleteSubList(llParseStringKeepNulls(path, [":"], []), start, end), ":");
}
//helper
string getNodes(string path, integer start, integer end) {
    return llDumpList2String(llList2List(llParseStringKeepNulls(path, [":"], []), start, end), ":");
}

//helper
string buildParamSet1(string path, integer page, string prompt, list additionalButtons, list pluginParams) {
    //pluginParams are: string pluginLocalPath, string pluginName, string pluginMenuParams, string pluginActionParams
    //We can't use colons in the promt, because they are used as a seperator in other messages
    //so we replace them with a UTF Symbol
    return llDumpList2String([
        path,
        page,
        llDumpList2String(llParseStringKeepNulls(prompt, [","], []), "‚"), // CAUTION: the 2nd "‚" is a UTF sign!
        llDumpList2String(additionalButtons, ",")
    ] + llList2List(pluginParams + ["", "", "", ""], 0, 3), "|");
}

integer getMmeWorkerNumber(string path) {
    //returns:
    //WorkerNumber
    
    while(path!="") {
        integer index=llListFindList(MmePluginBasePathList, [path]);
        if(~index) {
            return llList2Integer(MmePluginWorkerNumberList, index);
        }
        else {
            path=deleteNodes(path, -1, -1);
        }
    }
    return 0;
}

init() {
    MenuPaths = [];
    MenuButtons = [];
    MmePluginBasePathList=[];
    MmePluginWorkerNumberList=[];
    TotalNumberOfValidCards=0;
    TotalNumberOfStoredCards=0;

    //check if the script has a proper name
    string myScriptName=llGetScriptName();
    if(llSubStringIndex(myScriptName, MME_PLUGIN_SCRIPT_NAME)) {
        llOwnerSay("Error: The name of the script \"" + myScriptName + "\" must begin with \"" + MME_PLUGIN_SCRIPT_NAME + "\".");
        return;
    }
    //get the worker number
    integer length=llGetInventoryNumber(INVENTORY_SCRIPT);
    integer index;
    integer currentWorkerNumber;
    for(index=0; index<length; index++) {
        string currentName=llGetInventoryName(INVENTORY_SCRIPT, index);
        if(!llSubStringIndex(currentName, MME_PLUGIN_SCRIPT_NAME)) {
            currentWorkerNumber++;
            if(currentName == myScriptName) {
                MyWorkerNumber=currentWorkerNumber;
                MyPluginMenuName=MME_PLUGIN_MENU_NAME + (string)currentWorkerNumber;
                index=length;
            }
        }
    }
    //check if the configuration NC does exists
    UseMme=llGetInventoryType(MmeNc)==INVENTORY_NOTECARD;
    if(!UseMme) {
        llOwnerSay("To make use of the " + MME_PLUGIN_SCRIPT_NAME + " you need a configuration notecard with the name: " + MmeNc);
        return;
    }

    UseChangeMenuOrder=llGetInventoryType(MenuNc)==INVENTORY_NOTECARD;
    ScriptId=llGetInventoryKey(myScriptName);
    //Notice: the MenuMemoryExtension does not work (well) if you also use the ".Change Menu Order" mechanism
    //My point of view (Leona): avoid the ".Change Menu Order" and use Button Comments to sort the menu manually
    if(UseMme || UseChangeMenuOrder) {
        llSleep(1.5); //be sure that the NC reader script finished resetting
        if(UseMme) {
            llMessageLinked(LINK_SET, NC_READER_REQUEST, MmeNc, ScriptId);
        }
        if(UseChangeMenuOrder) {
            llMessageLinked(LINK_SET, NC_READER_REQUEST, MenuNc, ScriptId);
        }
    }
    else {
        BuildMenus([]);
    }
}

default{
    state_entry() {
        init();
    }
    
    link_message(integer sender, integer num, string str, key id) {
        if(num==PLUGIN_ACTION || num==PLUGIN_MENU) {
            //the menu script itself contains a few menu plugins.
            //the former admin menu is not part of it. We could simply use NCs for it.
            list params=llParseStringKeepNulls(str, ["|"], []);
            string path=llList2String(params, 0);
            integer page=(integer)llList2String(params, 1);
            string prompt=llList2String(params, 2);
            string additionalButtons=llList2String(params, 3);
            string pluginLocalPath=llList2String(params, 4);
            string pluginName=llList2String(params, 5);
            string pluginMenuParams=llList2String(params, 6);
            string pluginActionParams=llList2String(params, 7);
            
            if(pluginName==MyPluginMenuName) {
                if(num==PLUGIN_ACTION) {
                    // 1) Do the action if needed
                    // 2) correct the path if needed
                    // 3) finish with a PLUGIN_ACTION_DONE call
                    if(~llListFindList(MenuPaths, [path])) {
                        //this is a node
                        page=0;
                    }
                    else {
                        path=deleteNodes(path, -1, -1);
                    }
                    //PLUGIN_ACTION_DONE does an extra step through the core which isn't needed in this case,
                    //so instead of using the PLUGIN_ACTION_DONE we end this with an PREPARE_MENU_STEP2 call
                    llMessageLinked(LINK_SET, PREPARE_MENU_STEP2, buildParamSet1(path, page, prompt, [additionalButtons], []), id);
                }
                else if(num==PLUGIN_MENU) {
                    // 1) set a prompt if needed
                    // 2) generate your buttons if needed
                    // 3) finish with a PLUGIN_MENU_DONE call
                    llMessageLinked(LINK_SET, PLUGIN_MENU_DONE, buildParamSet1(path, page, prompt, getButtons(path, [additionalButtons]), []), id);
                }
            }
        }
//begin handle link message inputs
        else if(num == NC_READER_RESPONSE) {
            if(id==ScriptId) {
                if(!llSubStringIndex(str, MenuNc)) {
                    //Change Menu Order
                    BuildMenus(llList2List(llParseStringKeepNulls(str, [NC_READER_CONTENT_SEPARATOR], []), 3, -1));
                    str = "";
                }
                else {
                    //parse mme
                    list mmeConfig=llList2List(llParseStringKeepNulls(str, [NC_READER_CONTENT_SEPARATOR], []), 3, -1);
                    integer currentMmeConfigWorkerNumber;
                    while(llGetListLength(mmeConfig)) {
                        string line=llList2String(mmeConfig, 0);
                        mmeConfig=llDeleteSubList(mmeConfig, 0, 0);
                        string trimmedLine=llStringTrim(line, STRING_TRIM);
                        if(llGetSubString(trimmedLine, 0, 0)=="[" && llGetSubString(trimmedLine, -1, -1)=="]") {
                            //this is a line with the worker number. Example: [1]
                            currentMmeConfigWorkerNumber=(integer)llDeleteSubString(llDeleteSubString(trimmedLine, 0, 0), -1, -1);
                        }
                        else {
                            //this is a line with a path. Example: SET:Female
                            MmePluginBasePathList+=[line];
                            MmePluginWorkerNumberList+=[currentMmeConfigWorkerNumber];
                        }
                    }
                    //add buttons
                    integer index;
                    integer length=llGetListLength(MmePluginBasePathList);
                    for(index=0; index<length; index++) {
                        string path=llList2String(MmePluginBasePathList, index);
                        if(getMmeWorkerNumber(deleteNodes(path, -1, -1))==MyWorkerNumber) {
                            AddMenuButton(path, TRUE);
                        }
                    }
                    if(!UseChangeMenuOrder) {
                        BuildMenus([]);
                    }
                }
            }
        }
        else if(num == MEMORY_USAGE) {//dump memory stats to local
            llSay(0,
                "Memory used by " + llGetScriptName() + ": " + (string)llGetUsedMemory() + " of " + (string)llGetMemoryLimit()
                + ", leaving " + (string)llGetFreeMemory() + " memory free. \n"
                + "Storing " + (string)TotalNumberOfStoredCards + " out of " + (string)TotalNumberOfValidCards + " valid Notecards." 
                + " Worker number: " + (string) MyWorkerNumber
            );
        }
//end handle link message inputs
    }

    changed(integer change) {
        if(change & CHANGED_INVENTORY) {
            init();
        }
    }

    on_rez(integer params) {
        llResetScript();
    }
}
